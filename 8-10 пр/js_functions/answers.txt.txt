
 1. В чем разница между Function Declaration и Function Expression в контексте hoisting (поднятия)?
Function Declaration полностью "поднимается" (hoisted) в начало своей области видимости. Это означает, что функцию можно вызвать до ее объявления в коде:
```javascript
// Работает - функция поднята
console.log(sum(2, 3)); // 5

function sum(a, b) {
    return a + b;
}
```
Function Expression не поднимается полностью. Поднимается только объявление переменной, но не присвоение значения:
```javascript
// Ошибка - переменная sum поднята, но равна undefined
console.log(sum(2, 3)); // TypeError: sum is not a function

const sum = function(a, b) {
    return a + b;
};
```
2. Как работают rest parameters (...args) и в чем их отличие от arguments object?
Rest Parameters (...args) - современный синтаксис для работы с неограниченным количеством аргументов:
```javascript
function sum(...numbers) {
    return numbers.reduce((acc, val) => acc + val, 0);
}
```
Отличия от arguments object:
arguments - объект подобный массиву, ..args - настоящий массив
arguments содержит все аргументы, ...args только оставшиеся
arguments доступен в обычных функциях...args работает везде
…args можно использовать с деструктуризацие
3. Что такое замыкание (closure) и как оно связано с лексической областью видимости?
Замыкание - это функция, которая запоминает свое лексическое окружение даже после выполнения внешней функции.
```javascript
function createCounter() {
    let count = 0; // лексическое окружение
    
    return function() {
        count++; // доступ к переменной внешней функции
        return count;
    };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```
Связь с лексической областью видимости: Замыкание сохраняет ссылку на всю лексическую область видимости, в которой была объявлена функция.
4. Когда следует использовать рекурсию, а когда итерацию? Какие преимущества и недостатки у каждого подхода?
Рекурсия подходит для:
Древовидных структур данных
Задач, которые естественно рекурсивны (факториал, Фибоначчи)
Обхода в глубину
Преимущества рекурсии: читаемость, элегантность для рекурсивных задач
Недостатки: риск переполнения стека, большие затраты памяти
Итерация подходит для:
Простых циклов
Обработки массивов
Когда важна производительность
Преимущества итерации: лучшая производительность, контроль памяти
Недостатки: может быть менее читаемой для сложных алгоритмов
5. Как работают функции высшего порядка и какие встроенные методы массивов являются таковыми?
Функции высшего порядка - это функции, которые принимают другие функции как аргументы или возвращают функции.
Встроенные методы массивов-функции высшего порядка:
map() - преобразование каждого элемента
filter() - фильтрация элементов
reduce() - аккумуляция значений
forEach() - выполнение действия для каждого элемента
find() - поиск элемента
some() / every()- проверка условий

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2); // [2, 4, 6, 8, 10]
```
6. Что такое каррирование и какие практические преимущества оно дает?
Каррирование - преобразование функции от нескольких аргументов в последовательность функций с одним аргументом.
```javascript
// Обычная функция
const add = (a, b, c) => a + b + c;
// Каррированная версия
const curriedAdd = a => b => c => a + b + c;
```
Преимущества:
Частичное применение - можно создавать специализированные функции
Композиция - легче комбинировать функции
Переиспользование кода
Ленивые вычисления
7. Как работает мемоизация и в каких случаях ее использование наиболее эффективно?
Мемоизация - кэширование результатов вызовов функций для одинаковых аргументов.
```javascript
function memoize(fn) {
    const cache = new Map();
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = fn.apply(this, args);
        cache.set(key, result);
        return result;
    };
}
```
Эффективно использовать для:
Чистых функций (детерминированных)
Функций с дорогими вычислениями
Рекурсивных функций (например, Фибоначчи)
Функций с небольшим количеством уникальных аргументов
8. В чем разница между debounce и throttle и когда следует использовать каждый подход?

Debounce - откладывает вызов функции до истечения периода бездействия:
```javascript
// Использовать для: поиска, валидации форм, resize событий
function debounce(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
}
```
Throttle - ограничивает частоту вызовов функции:
```javascript
// Использовать для: скролла, drag&drop, игровых контролов
function throttle(fn, interval) {
    let lastCall = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastCall >= interval) {
            lastCall = now;
            fn.apply(this, args);
        }
    };
}
```
9. Как функции-генераторы (function) отличаются от обычных функций
Функции-генераторы:
Объявляются как function
Могут приостанавливать выполнение и возобновлять его
Возвращают итератор
Используют yield для возврата значений

```javascript
Function numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

const generator = numberGenerator();
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
```
Отличия:
Многократный возврат значений
Сохранение состояния между вызовами
Ленивые вычисления
Асинхронные возможности (async/await построены на генераторах)
10. Какие принципы функционального программирования вы применили в ходе работы и в чем их benefits?
Примененные принципы:
1. Чистые функции - функции без побочных эффектов
   ```javascript
   function sum(...numbers) {
       return numbers.reduce((acc, val) => acc + val, 0);
   }
   ```
Benefits: предсказуемость, тестируемость
2. Неизменяемость - создание новых объектов вместо изменения существующих
   ```javascript
   function myMap(array, callback) {
       const result = []; // новый массив
       for (let i = 0; i < array.length; i++) {
           result.push(callback(array[i], i, array));
       }
       return result;
   }
   ```
Benefits: отсутствие побочных эффектов, проще отладка
3. Функции высшего порядка - композиция и абстракция
   ```javascript
   function compose(...functions) {
       return function(initialValue) {
           return functions.reduceRight((value, fn) => fn(value), initialValue);
       };
   }
   ```
Benefits: переиспользование кода, модульность
4. Каррирование - частичное применение функций
Benefits: гибкость, композиция
5. Замыкания - инкапсуляция состояния
   ```javascript
   function secretMessage(password, message) {
       return function(checkPassword) {
           return checkPassword === password ? message : "Доступ запрещен";
       };
   }
   ```
Benefits: приватность данных, создание специализированных функций
Общие benefits функционального программирования:
Более предсказуемый код
Упрощенное тестирование
Лучшая читаемость
Упрощенная параллельная обработка
Меньше багов из-за побочных эффектов
