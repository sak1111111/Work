1. В чем разница между временной сложностью O(n) и O(n²)? Приведите примеры алгоритмов с каждой сложностью.
O(n) - линейная сложность:
Время выполнения растет пропорционально размеру входных данных пример: поиск элемента в неотсортированном массиве, обход массива
```javascript
// O(n) - линейный поиск
function findElement(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) return i;
    }
    return -1;
}
```
O(n²) - квадратичная сложность:
Время выполнения растет пропорционально квадрату размера входных данных
Пример: пузырьковая сортировка, проверка всех пар элементов
```javascript
// O(n²) - пузырьковая сортировка
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
```
2. Как работает алгоритм бинарного поиска и почему его сложность O(log n)?
Принцип работы:
1. Находим средний элемент отсортированного массива
2. Сравниваем с искомым значением
3. Если значение равно - возвращаем индекс
4. Если значение меньше - ищем в левой половине
5. Если значение больше - ищем в правой половине
6. Повторяем до нахождения или исчерпания массива

```javascript
function binarySearch(sortedArr, target) {
    let left = 0;
    let right = sortedArr.length - 1; 
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (sortedArr[mid] === target) {
            return mid;
        } else if (sortedArr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```
Сложность O(log n) потому что на каждом шаге алгоритм уменьшает область поиска вдвое. Для массива из n элементов максимальное количество шагов равно log₂(n).
3. Какие преимущества и недостатки у пузырьковой сортировки по сравнению с другими алгоритмами сортировки?
Преимущества:
Простота реализации и понимания
Стабильность (сохраняет порядок равных элементов)
In-place алгоритм (не требует дополнительной памяти)
Хорошо работает на почти отсортированных массивах (с оптимизацией)
Недостатки:
O(n²) в худшем и среднем случае - медленный для больших массивов
Неэффективен по сравнению с быстрой сортировкой (O(n log n)) Большое количество обменов элементов
Сравнение:
Быстрая сортировка: быстрее, но сложнее, нестабильная
Сортировка слиянием: стабильная, но требует O(n) дополнительной памяти
Пирамидальная сортировка: O(n log n), но нестабильная
4. Как можно оптимизировать функцию проверки на простое число для больших чисел?
Базовые оптимизации:
1. Проверка делимости только до √n
2. Пропуск четных чисел после проверки на 2
3. Проверка делимости на числа вида 6k±1
```javascript
function isPrimeOptimized(n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 === 0 || n % 3 === 0) return false;
    // Проверяем делители вида 6k ± 1
    for (let i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }
    return true;
}
```
Дополнительные оптимизации для очень больших чисел:
Тест Миллера-Рабина (вероятностный)
Решето Эратосфена для множественной проверки
Кэширование результатов
5. В чем разница между рекурсивной и итеративной реализацией алгоритма Фибоначчи?
Рекурсивная реализация:
```javascript
function fibonacciRecursive(n) {
    if (n <= 1) return n;
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
```
Плюсы: читаемость, простота реализации
Минусы: экспоненциальная сложность O(2ⁿ), переполнение стека
Итеративная реализация:
```javascript
function fibonacciIterative(n) {
    if (n <= 1) return n;
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        const temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
```
Плюсы: линейная сложность O(n), постоянная память
Минусы: менее интуитивная для математической формулы
6. Какие методы отладки вы использовали при реализации алгоритмов?
Основные методы:
1. Console.log отладка:
```javascript
function bubbleSort(arr) {
    console.log('Исходный массив:', arr);
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
            console.log(`Сравниваем ${arr[j]} и ${arr[j + 1]}`);
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                console.log('Обмен:', arr);
            }
        }
    }
    return arr;
}
```
2. Точки останова в DevTools
3. Модульное тестирование
4. Визуализация алгоритмов
5. Пошаговое выполнение
7. Как работает алгоритм Евклида для нахождения НОД и почему он эффективен?
Принцип работы: НОД(a, b) = НОД(b, a mod b), повторяем пока b ≠ 0
```javascript
function gcd(a, b) {
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return Math.abs(a);
}
```
Пример: НОД(48, 18)
1. 48 % 18 = 12 → НОД(18, 12)
2. 18 % 12 = 6 → НОД(12, 6)
3. 12 % 6 = 0 → НОД(6, 0) = 6
Эффективность: Алгоритм имеет сложность O(log(min(a, b))), так как на каждом шаге числа уменьшаются экспоненциально.
8. Какие edge cases (крайние случаи) нужно учитывать при реализации алгоритмов работы с массивами?
Основные edge cases:
1. Пустой массив:
```javascript
function findMax(arr) {
    if (arr.length === 0) throw new Error("Массив не должен быть пустым");
    // ... остальная реализация
}
```

2. Массив с одним элементом
3. Отрицательные числа
4. Очень большие/маленькие числа
5. Массивы с одинаковыми элементами
6. Уже отсортированные массивы
7. Массивы, отсортированные в обратном порядке
8. Массивы с null/undefined значениями
9. Очень большие массивы (проблемы с памятью)
10. Нечисловые значения в числовых алгоритмах
9. Как можно улучшить функцию удаления дубликатов для работы с большими массивами?
Базовый подход (медленный для больших массивов):
```javascript
function removeDuplicatesSlow(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
}
// Сложность O(n²)
```
Оптимизированный подход:
```javascript
function removeDuplicatesFast(arr) {
    const seen = new Set();
    const result = [];
    for (const item of arr) {
        if (!seen.has(item)) {
            seen.add(item);
            result.push(item);
        }
    }
    return result;
}
// Сложность O(n)
```
Дополнительные улучшения:
Использование Map для объектов
Параллельная обработка для очень больших массивов
Потоковая обработка
Bloom filters для приблизительного удаления дубликатор
10. Какие принципы написания чистого кода вы применили при реализации алгоритмов?
Примененные принципы
1. DRY (Don't Repeat Yourself):
```javascript
// Плохо - повторение кода
function processArray(arr) {
    // Дублирующаяся логика
}
// Хорошо - переиспользование
function reusableHelper(data) {
    // Общая логика
}
```
2. KISS (Keep It Simple, Stupid):
```javascript
// Простая читаемая реализация вместо излишне сложной```
3. Осмысленные имена:
```javascript
// Плохо
function f(a, b) { ... }

// Хорошо
function calculateGCD(number1, number2) { ... }
```
4. Единственная ответственность:
```javascript
// Каждая функция делает одну вещь и делает ее хорошо
function isPrime(n) { ... }
function factorial(n) { ... }
function fibonacci(n) { ... }
```
5. Обработка ошибок:
```javascript
function factorial(n) {
    if (n < 0) throw new Error("Факториал определен для n >= 0");
    if (!Number.isInteger(n)) throw new Error("n должно быть целым числом");
    // ... реализация
}
```
6. Комментарии для сложных алгоритмов:
```javascript
/
 Алгоритм Евклида для нахождения НОД
 Сложность: O(log(min(a, b)))
 /
function gcd(a, b) {
    // ... реализация
}
```
7. Консистентное форматирование
8. Тестируемость - функции чистые и предсказуемые
9. Принцип наименьшего удивления - функции работают так, как ожидается
