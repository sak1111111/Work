1. В чем разница между useState и useReducer? Когда использовать каждый?
useState - это хук для управления простым состоянием компонента. Он возвращает текущее значение и функцию для его обновления.

useReducer - это хук для управления сложным состоянием, похожий на Redux. Он принимает редюсер функцию и начальное состояние, возвращает текущее состояние и функцию dispatch.

Когда использовать:

useState: для простых состояний (примитивы, простые объекты), независимых значений

useReducer: для сложной логики обновления, связанных состояний, больших объектов состояния, когда следующее состояние зависит от предыдущего

Пример использования useReducer:

javascript
const [state, dispatch] = useReducer(reducer, initialState);
dispatch({ type: 'INCREMENT' });
2. Как работает массив зависимостей в useEffect? Что произойдет если его не указать?
Массив зависимостей определяет, при изменении каких переменных эффект должен перезапускаться.

Варианты:

[] - пустой массив: эффект запускается только при монтировании компонента

[var1, var2] - массив с зависимостями: эффект запускается при изменении любой из переменных

Не указан - эффект запускается при каждом рендере компонента

Если не указать массив зависимостей: эффект будет выполняться после каждого рендера компонента, что может привести к проблемам с производительностью и бесконечным циклам.

3. Что такое "stale closure" в хуках и как использовать функциональные обновления чтобы избежать этой проблемы?
Stale closure (устаревшее замыкание) - ситуация, когда функция внутри эффекта или колбэка использует устаревшее значение переменной из замыкания, а не актуальное.

Проблема возникает когда:

Колбэк использует состояние, но захватывает его старое значение

Асинхронные операции обращаются к устаревшим значениям

Решение: использовать функциональные обновления:

javascript
// Вместо этого (может привести к stale closure):
setCount(count + 1);

// Используйте это (функциональное обновление):
setCount(prevCount => prevCount + 1);
4. Когда действительно нужны useCallback и useMemo? Не являются ли они преждевременной оптимизацией?
useCallback - кеширует функцию между рендерами
useMemo - кеширует результат вычислений между рендерами

Когда действительно нужны:

Передача колбэков дочерним компонентам, обернутым в React.memo

Дорогие вычисления, которые не должны выполняться при каждом рендере

Референциальное равенство в зависимостях других хуков

Оптимизация производительности при ререндерах больших списков

Преждевременная оптимизация: Часто эти хуки используются без реальной необходимости. Сначала следует измерить производительность и убедиться в наличии проблем.

5. Как useRef отличается от useState? В каких сценариях useRef незаменим?
Отличия:

useRef не вызывает ререндер при изменении значения, useState - вызывает

useRef сохраняет значение между рендерами, но изменения не триггерят обновление

useRef можно использовать для прямого доступа к DOM элементам

useRef незаменим для:

Доступа к DOM элементам (ссылки на input, div и т.д.)

Хранения мутирующих значений (таймеры, инстансы классов)

Избежания ререндеров когда нужно сохранить значение

Хранения предыдущих значений состояния

6. Какие правила хуков существуют и почему их нельзя нарушать?
Основные правила:

Вызывать хуки только на верхнем уровне - нельзя вызывать в условиях, циклах, вложенных функциях

Вызывать хуки только из React-функций - функциональных компонентов или кастомных хуков

Почему нельзя нарушать: React полагается на порядок вызова хуков для корректного сопоставления состояния между рендерами. Нарушение порядка приводит к непредсказуемому поведению и багам.

7. Как создать кастомный хук и какие лучшие практики следует соблюдать?
Создание кастомного хука: функция, начинающаяся с "use", которая может использовать другие хуки.

Лучшие практики:

Имена всегда начинаются с "use"

Один хук - одна ответственность

Документировать интерфейс (параметры, возвращаемые значения)

Тестировать изолированно

Следовать принципам композиции

Обрабатывать ошибки корректно

Пример:

javascript
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    // логика инициализации
  });
  
  // логика хука
  return [value, setValue];
}
8. В чем преимущества использования useContext перед передачей props через несколько компонентов?
Преимущества useContext:

Избежание "prop drilling" (проброса props через множество компонентов)

Централизованное управление состоянием

Более чистый и читаемый код

Легкое переиспользование логики

Упрощение рефакторинга

Когда использовать:

Глобальные настройки (тема, язык)

Данные пользователя

Кэшированные данные

Состояние аутентификации

9. Как обрабатывать асинхронные операции в кастомных хуках?
Способы обработки:

Использовать useState для состояний загрузки, ошибки и данных

useEffect для side effects и отмены подписок

Очистка с помощью abort controller для отмены fetch запросов

Обработка ошибок через try/catch

Использование флагов для избежания состояния гонки

Пример:

javascript
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!cancelled) {
          const result = await response.json();
          setData(result);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true;
    };
  }, [url]);

  return { data, loading, error };
}
10. Какие способы отладки хуков вы знаете?
Способы отладки:

React DevTools - просмотр состояния, эффектов, зависимостей

Console.log в эффектах и колбэках для отслеживания выполнения

useDebugValue для кастомных хуков (отображение в DevTools)

Strict Mode для обнаружения неожиданных побочных эффектов

Тестирование с React Testing Library

Линтинг с ESLint правилами для хуков

Кастомные хуки для логирования

Брейкпоинты в инструментах разработчика

Пример useDebugValue:

javascript
function useCustomHook() {
  const [value, setValue] = useState(null);
  useDebugValue(value ?? 'loading');
  return [value, setValue];
}